## Summary of Chapter 4 – Builds and Makefiles

This chapter explains how C source code is transformed into executable files, the roles of compiling, assembling, and linking, the differences between assembly and machine code, and how makefiles simplify multi-file C builds.

---

### 4.1 The Compilation Process

#### Main Concepts

- The transformation from source code to executable involves several steps:
  1. **Preprocessing**: Handles directives like `#include` and `#define`.
  2. **Compiling**: Converts preprocessed code to assembly language.
  3. **Assembling**: Converts assembly to machine code (object files).
  4. **Linking**: Combines object files and libraries into a final executable.

- **CPU**: Executes machine code, not high-level language or even assembly directly.
- **Machine Code**: Platform-specific binary instructions.
- **Assembly Code**: Human-readable, one-to-one mapping to machine instructions, still platform-specific.

#### Compilation Diagram

**Description:**  
A diagram (not shown here) illustrates three stages:
- C source → Assembly code → Machine code
This shows the transformation through preprocessing, compiling, and assembling before reaching the executable stage.

---

#### Preprocessing

- **Directives** like `#include` insert header file contents into source files.
- `#define` constants are replaced throughout the code.
- Use `gcc -E` to see preprocessed output.

**Code Example: myDefinitions.h**
```c
#define DAYS_OF_WEEK   7
#define PI             3.14159
#define MAX            15
```
**Explanation:**  
Defines constants to be used throughout the program, improving code clarity and maintainability.

**Code Example: headerExample.c**
```c
#include <stdio.h>
#include "myDefinitions.h"

int main() {
  int  x = MAX;
  int *y = &x;

  printf("x + *y = %d\n", x + *y);
  printf("Days = %d, PI = %f\n", DAYS_OF_WEEK, PI);
}
```
**Explanation:**  
Includes custom header for constants, shows use of definitions in main program.

---

#### Conditional Compilation

- **Directives** such as `#ifdef`, `#ifndef` allow selective compilation for debugging or platform-specific code.

**Code Example: ifdefExample.c**
```c
#include <stdio.h>
#include "myDefinitions.h"

#define DEBUG 1

int main() {
  int  x = MAX;
  int *y = &x;

  #ifdef DEBUG
    printf("*y = %d\n", *y);
  #endif
  printf("x + *y = %d\n", x + *y);
  printf("Days = %d, PI = %f\n", DAYS_OF_WEEK, PI);
}
```
**Explanation:**  
When `DEBUG` is defined, the program prints extra information for debugging. If not, those lines are skipped.

---

#### Assembly Code

- After preprocessing, the compiler translates code to assembly (`gcc -S`).
- Assembly code is more readable than machine code but still low-level.

**Sample Assembly Excerpt:**
```
movl $15, -20(%rbp)           ; assign 15 to variable x
leaq -20(%rbp), %rax          ; address of x into %rax
movq %rax, -16(%rbp)          ; store pointer to x
```
**Explanation:**  
Instructions move values and addresses to registers and memory, matching the high-level logic.

---

#### Machine Code

- **Machine code** is the binary format executed by CPUs.
- Created from assembly via the assembler (`gcc -c`).
- Object files (`.o`) are binary, platform-specific, and not easily human-readable.
- **Hex Dumps:** Display binary content as hexadecimal and ASCII (e.g., `.ELF` header for Linux executables).

---

#### Linking

- **Linking** combines object files and libraries into a single executable.
- **Static Linking:** Copies library code into the executable (larger, faster at runtime).
- **Dynamic Linking:** Loads libraries at runtime (smaller, may be slower).

**Code Example: Multi-file Linking**
```c
// linkExampleMain.c and linkExampleUtil.c
gcc -c linkExampleMain.c
gcc -c linkExampleUtil.c
gcc -o linkExample linkExampleMain.o linkExampleUtil.o
```
**Explanation:**  
Each source file is compiled to an object file, then the linker combines them into an executable.

---

### 4.2 Makefiles

#### Main Concepts

- **Makefile:** Text file used by the `make` tool to automate compiling and linking.
- **Advantages:**
  - Simplifies build process to a single command.
  - Tracks dependencies — only recompiles changed files.

**Basic Makefile Example:**
```makefile
all: main util
	gcc -o linkExample linkExampleMain.o linkExampleUtil.o

main: linkExampleMain.c linkExampleTypes.h
	gcc -c linkExampleMain.c

util: linkExampleUtil.c linkExampleTypes.h
	gcc -c linkExampleUtil.c

clean:
	rm -f linkExampleMain.o linkExampleUtil.o linkExample
```
**Explanation:**  
- The `all` label builds the final executable, depending on object files.
- `main` and `util` describe how to compile each object file from sources and headers.
- `clean` removes built files, keeping the directory tidy.

**Variable Use in Makefiles:**
```makefile
OBJ = linkExampleMain.o linkExampleUtil.o

all: main util
	gcc -o linkExample $(OBJ)
```
**Explanation:**  
Variables reduce repetition and simplify updates.

**Selective Builds:**
- Run `make main` to only compile main object file.
- Run `make clean` to remove build artifacts.

---

#### Advanced Makefile Example

- Shows variables for compilers and libraries.
- Demonstrates dependency tracking for complex projects.
- `clean` target removes object files, executables, and temporary files (like Emacs backups).

**Code Snippet: Clean Target**
```makefile
clean:
	rm -f *.o *~ sp
```
**Explanation:**  
Removes all object files, backup files (`*~`), and the executable (`sp`).

---

### Additional Notes

#### Binary and Hex Dumps

- The document includes hex dumps of object and executable files.
- **Purpose:** To illustrate that machine code is binary, not human-readable, and platform-specific.
- **Relevance:** Reinforces the need for high-level language and tools to manage complexity.

---

### Synthesis

**Key Takeaways:**
- The build process transforms readable C code into low-level instructions the CPU can execute, involving several stages: preprocessing, compiling, assembling, and linking.
- Makefiles are essential for automating and managing builds, especially for multi-file projects, improving efficiency and organization.
- Understanding the distinction between source code, assembly, and machine code, as well as static and dynamic linking, is crucial for effective C programming and software engineering.
- Proper use of header files, conditional compilation, and build automation tools like `make` leads to more maintainable, scalable, and robust codebases.

---

**No mathematical formulas or graphical plots** are present in this document.  
All explanations are provided in English, with code examples formatted for clarity.